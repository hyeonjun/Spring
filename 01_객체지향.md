# 객체지향
현실에 존재하는 사물을 있는 그대로 모델링하여, 이들의 행위와 속성을 정의하고, 절차적이 아닌 객체가 중심이 되어 실제 사물이 동작하는 빙식으로 설계하는 것

* 사물: 객체
* 해당 사물이 하는 행위: Method
* 사물이 가지는 속성: 변수 Variable

### 객체의 3 요소
* 상태 유지 (객체의 상태)
  * 객체는 상태 정보를 저장하고, 유지되어져야 하며 이러한 속성은 변수로 정의
  * 속성값이 바뀜으로 인해 객체 상태가 변경될 수 있어야 함
* 기능 제공(객체의 책임)
  * 객체는 기능을 제공해야 함 -> Method의 제공
  * 캡슐화와 연관이 있으며, 외부로부터 직접 속성에 접근하여 변경하는 것이 아닌 객체가 제공하는 Method로 기능 제공이 되어져야 함
* 고유 식별자 제공(객체의 유일성)
  * 각각의 객체는 고유한 식별자를 가져야 함

### 물리 객체와 개념 객체
* 물리 객체
  * 물리적 객체는 실제로 사물이 존재하며, 이를 클래스로 정의한 객체를 의미
* 개념 객체
  * 웹 시스템의 Service에 해당, 비즈니스 로직을 처리하는 부분을 의미
  * 비즈니스 로직에서는 여러 객체를 서로 상호작용하도록 하며, 객체가 제공하는 오퍼레이션 Method를 통해 객체 속성을 변경시킨다.

# 객체지향의 4대 특성
### 1.캡슐화
* 객체의 속성을 보호하기 위해 사용
* Method 설계
  * 속성이 선언 후 상태 변경하는 기능을 제공
  * 실물 객체가 가진 기능을 모두 제공해야함
  * 각각의 메서드는 서로 관련성이 있어야 함
  * 객체 안의 메서드는 객체 안의 속성을 처리해야 하며, 다른 객체를 전달받아 해당 다른 객체에 정의된 속성을 직접 처리하면 안 된다.
    * 메서드 실행에 필요한 값들은 객체의 형태가 아닌 매개변수 형태로 전달되어져야 한다.
  * Getter/Setter Method
  * CRUD Method
  * Business Logic Method: 비즈니즈 로직 처리르 위한 메서드 제공
  * 객체 생명 주기 처리 Method: destroy(), disconnect(), quit() 등 소멸에 대한 메서드
  * 객체 영구성 관리 Method
    * 영구성(유효성) 속성에 대한 변경이 필요한 경우 외부에서는 접근이 불간으하도록 private로 선언하며, 내부의 다른 메서드를 통해 사용되도록 함
  * Method 속성은 반드시 1개에 속할 필요는 없으며, 여러 속성에 해당될 수 있음
  * 장점
    * 추상화 제공
      * 실제로 메서드가 어떻게 동작하는지는 외부에서 이해할 필요가 없음
      * 단순 호출만으로 해당 기능을 실행할 수 있고, 이를 통해 객체 단위 프로그램 설계가 가능
    * 재사용성 향상
      * 한 객체에 관련된 속성 및 메서드는 모두 캡슐화 형태로 제공
      * 객체의 모듈성과 응집도가 높아짐
    * 유지보수성 향상
    * 무결성
      * Getter/Setter를 제외한 public method는 입력된 매개변수를 Validation한 후 실행하는 것을 기본으로 함
      * 이 Validation을 통해 객체의 값을 변경하거나 값에 대한 유효성을 가질 수 있음

### 2.상속
* 객체 지향에서의 상속은 속성의 상속이 아닌 하위로 내려갈수록 구체화되는 것
* 효과
  * 프로그램 구조에 대한 이해도 향상
    * 최상위 클래스의 구조를 파악하면 하위클래스의 동작을 이해할 수 있음
  * 재사용성 향상
    * 상속을 이용하여 해당 클래스에 필요한 속성 및 메서드를 모두 정의하지 않고, 상속을 받아 사용할 수 있음
  * 확장성 향상
    * 일관된 형태의 클래스 객체를 추가할 수 있어 간단하게 프로그램 확장이 가능
  * 유지보수성 향상
    * 각 객체마다 자신의 메서드를 정의하고 있다면, 코드 수정에 많은 작업이 필요
    * 상속을 사용한 경우 일관된 형태로 작성이 가능

### 3.다형성
* 한 객체가 상속을 통해 기능을 확장하거나 다른 여러 형태(객체)로 재구성되는 것
* 같은 이름의 속성을 유지함으로써 속성을 사용하기 위한 인터페이스를 유지하고 메서드 이름을 낭비하지 않음
  * 코드의 재사용성을 향상시켜 유지보수성 향상

### 4.추상화
* 객체 지향에서의 추상화는 모델링이다.
* 공통적인 부분 또는 특정 특성을 분리해서 재조합하는 부분이 추상화이다.
* 다형성, 상속 모두 추상화에 속함

# 객체 지향 설계 5원칙 SOLID
좋은 소프트웨어 설계를 위해서는 결합도(coupling)는 낮추고 응집도(cohension)는 높여야 함
* 결합도
  * 모듈(클래스) 간의 상호 의존 정도를 나타내는 지표로, 결합도가 낮으면 모듈 간의 상호 의존성이 줄어들어 객체의 재사용 및 유지보수가 유리함
* 응집도
  * 하나의 모듈 내부에 존재하는 구성 요소들의 기능적 관련성으로 응집도가 높은 모듈은 하나의 책임에 집중하고 독립성이 높아져, 재사용 및 유지보수가 용이

* SRP(Single Responsibility Principle) - 단일 책임 원칙
  * 한 클래스는 하나의 책임만 가져야 함
* OCP(Open/Closed Principle) - 개방 폐쇄 원칙
  * 자신의 확장에는 열려 있고, 주변의 변화에는 닫혀 있어야 함
  * 상위 클래스 또는 인터페이스를 중간에 둠으로써, 자신은 변화에 대해서는 폐쇄적이지만 인터페이스는 외부 변화에 대해서 확장을 개방해줄 수 있다.
  * JDBC와 Mybatis, Hibernate 등, Java의 Stream(Input, Output)
* LSP(Liskov Substitution Principle) - 리스코프 치환 원칙
  * 서브 타입은 언제나 자신의 상위 타입으로 교체할 수 있어야 함
* ISP(Interface Segregation Principle) - 인터페이스 분리 원칙
  * 클라이언트는 자신이 사용하지 않는 메서드에 의존 관계를 맺으면 안된다
  * 프로젝트 요구 사용과 설계에 따라 SRP(단일 책임 원칙) / ISP(인터페이스 분리 원칙)를 선택함
* DIP(Dependency Inversion Principle) - 의존 역전 원칙
  * 자신보다 변하기 쉬운 것에 의존하지 말아야 함
  * 추상화에 의존 O / 구체화에 의존 X